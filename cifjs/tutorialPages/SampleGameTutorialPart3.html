
<html>
<head>
	<title>Making a Sample Game. Part 3.</title>
	<link href="tutorialPageStyle.css" rel="stylesheet" type="text/css">
	<script src="https://google-code-prettify.googlecode.com/svn/loader/run_prettify.js"></script>
</head>
<body>

<p>

<p>
And now we find ourselves at Part 3 of this sample game tutorial. We've come a long way together, but we still have a ways to go before we become bonified, certified CiF superstars. Up until this point, we've primarily just been dealing with generic html and css, setting up localhosts, and dabbling in the lightest of javascript. But no more! This part of the tutorial will teach you how to set up your social schema!
<p>

<h2>What Is a Social Schema</h2>

CiF will be keeping track of a lot of information in your social world. Things like...
<ul>
<li>The characters that populate your world</li>
<li>The history or backstory of those characters</li>
<li>The types of social relationships in your world</li>
<li>The social considerations your characters have that will govern their behavior</li>
<li>The actions that characters can take to influence the social state of the world</li>
</ul>

As a CiF author, it'll be up to you to define these things! It might seem like a lot, but once we get started hopefully you'll find that defining the social qualities of your world is actually pretty fun! You'll want all of the components of the schema to be in their own folder, with an appropriate descriptive name such as <i>data</i>.

<h2>Define Your Cast of Characters</h2>

Let's start off with an easy one to get our blood flowing: defining the characters that make up our world. As we already know from <a href="tutorial-SampleGameTutorialPart2.html">Part 2</a> of the tutorial, Lovers and Rivals is going to have three characters: The Hero, the Love, and the Rival. Defining these characters is as easy to whipping up a teeny tiny .json file that we'll call <i>cast.json</i>

<h3>Complete Cast File</h3>
<pre class="prettyprint">
{
	"cast": {
		"hero": {
			"name": "You"
		},
		"love": {
			"name": "Love"
		},
		"rival": {
			"name": "Rival"
		}
	}
}
</pre>

<p>
And that's all we need! For those of you not super familiar with json, even though it looks a little weird with all those colons and curly braces, it isn't that scary! Essentially, we're creating a "cast" object, that in turn has three objects inside of it, hero, love, and rival. And each of those sub-objects (hero, love, and rival) each has a name property. The 'hero' and 'love' and 'rival' objects in the cast will be used interally by CiF. The name property is something that can be used in your game; you can think of it as the 'display name' for the character. If you want, you can add additional properties for each of the characters underneath their name property, but for the purposes of this tutorial we'll just assume you've only defined their names.
</p>

<p>

So see, not so bad right? Now that we have a cast (and have refreshed our memories on the subject of json), we can create the somewhat confusingly named schema file!
</p>

<h2>Define Your Social Schema</h2>

<p>

What's that, you say? Isn't this whole part called defining the social schema? Er, well, yes, you caught us. Your social schema folder will in fact have a schema file inside of it. We should really change the name of something. But until we do, we'll just accept that we're about to define a social schema file inside of our social schema.

</p>

<p>
Your schema file is where you'll define the very types of social state that can befall your characters. Your schema will be the raw material that your characters will keep track of and reason about to determine what actions to take. For a detailed overview of the schema, check out <a href="tutorial-CiFUserREADME.html#schema">this part of the CiF user's guide!</a>
</p>

<p>

Okay! Finished reading up on what a schema is? Great! Let's start setting up the schema that we'll be using for Lovers and Rivals.

</p>

<pre class="prettyprint">
{
	"schema": [
		{
			"class": "feeling",
			"isBoolean": false,
			"directionType": "directed",
			"types": ["closeness", "attraction"],
			"defaultValue": 0,
			"minValue": 0,
			"maxValue": 100,
			"allowIntent": true
		},
		{
			"class" : "mood",
			"isBoolean" : true,
			"directionType" : "undirected",
			"types": ["confident", "unsure"],
			"allowIntent" : false,
			"defaultValue" : false,
			"duration" : 3
		}
	]
}
</pre>

<p>
	So, here we're defining two classes of social state: <i>feelings</i> and <i>moods</i>. Feelings, in this world, are numeric (specified by the line <i>"isBoolean": false</i>), and involve two people (specified by the line <i>"directionType" : "directed"</i>). The two types of feelings that we'll have in this world are "closeness" and "attraction" -- with the idea being that you can be close to someone (say having a closeness score of 80 or more) without being attracted to them (such as a family member, or a good friend). The converse is also true; you can be attracted to someone without being close to them (such as pining for a crush from afar, as we find The Hero to be doing at the beginning of Lovers and Rivals). The line <i>"allowIntent": true</i> means that you'll be able to author actions for characters to take to adjust these values.
</p>

<p>
	We define moods to be boolean as opposed to numeric; either characters have a mood or they do not--they can't be "60" confident or "20" unsure. Their directionType is undirected, which means they only apply to an individual character (i.e., they are confident or unsure in themselves, independant of anyone else in the social world), their moods will naturally fade away after three turns (thanks to the line <i>"duration": 3</i>) and characters can <i> not </i> take actions to specifically give themselves (or take away) moods.
</p>

<p>
	It should be stated that all of the schema components we're defining are simply the artistic choices made for Lovers and Rivals. In your own work, maybe you'll want to have actions that affect moods. And maybe you won't even want to call them moods. There's nothing sacred about any of these settings; they were just the choices made to get our little game up and running. So run wild when defining your own social schema!
</p>

<p>Now that we have a pretty good idea as to what the parts of a social schema look like, we'll present the rest of the schema file without comment:</p>

<h3> Complete Schema File </h3>

<pre class="prettyprint">
{
	"schema": [
		{
			"class": "feeling",
			"isBoolean": false,
			"directionType": "directed",
			"types": ["closeness", "attraction"],
			"defaultValue": 0,
			"minValue": 0,
			"maxValue": 100,
			"allowIntent": true
		},
		{
			"class" : "mood",
			"isBoolean" : true,
			"directionType" : "undirected",
			"types": ["confident", "unsure"],
			"allowIntent" : false,
			"defaultValue" : false,
			"duration" : 3
		},
		{
			"class" : "attribute",
			"types" : ["strength", "intelligence"],
			"isBoolean" : false,
			"directionType" : "undirected",
			"allowIntent" : true,
			"defaultValue" : 0,
			"maxValue" : 100,
			"minValue" : 0
		},
		{
			"class" : "trait",
			"isBoolean" : true,
			"directionType" : "undirected",
			"types" : ["hero", "love", "rival", "anyone"],
			"allowIntent" : false,
			"defaultValue" : false
		},
		{
			"class": "SFDBLabel",
			"types": ["romantic-failure", "romantic-advance"],
			"isBoolean": true,
			"directionType": "directed",
			"defaultValue": false,
			"allowIntent": false,
			"duration": 0
		},
		{
			"class": "SFDBLabelUndirected",
			"types": ["embarrassing", "self-involved"],
			"isBoolean": true,
			"directionType": "undirected",
			"defaultValue": false,
			"allowIntent": false,
			"duration": 0
		}
	]
}


</pre>

<p>

Ok, I lied, here's a little bit of additional commentary. The 'trait' class you'll see has four types: "hero", "love", "rival", and "anyone." You might find that its useful to have something akin to this in your future endeavors to have a way to reference specific characters in your system, by giving every character the trait of their own name. It can also be useful to have an 'anyone' trait that you'll apply to every character, in instances where it doesn't matter who the character is interacting with.

</p>

<p>
The SFDBLabels are boolenas with a duration of 0 -- that's an important sign to CiF that these are classes that refer not so much as to 'state' but rather to 'events.' If you want to keep track of specific acts that were done (e.g., a character did something embarrasing) as opposed to state (e.g., a character was feeling embarrassed), then you'll want to make use of these SFDBLabel classes.
</p>

<h2>Define the Backstory of the World</h2>

<p>
	In order to make your world feel like a living, breathing thing, it helps if the characters come equipped with pre-existing relationships with each other. This gives the player the sense that they are stumbling into a world with history, loaded with characters that already love and hate each other, as appropriate. We'll define the history of our world in a <i>history.json</i> file.
</p>

<p>The history file is essentially going to be specify the state of the world at each time step you care to define through the use of predicates.  <a href="tutorial-CiFUserREADME.html#predicate">You can read up a little on predicates here</a>, but we'll go over them here as well--they're an important concept for the CiF author to grasp! Let's take a peek at what the history file will look like.
	</p>

<pre class="prettyprint">
{
	"history": [{
		"pos": 0,
		"data": [{
			"class" : "trait",
			"type" : "anyone",
			"first" : "love",
			"value" : true
		},{
			"class" : "attribute",
			"type" : "strength",
			"first" : "hero",
			"value" : 0
		},{
			"class" : "attribute",
			"type" : "intelligence",
			"first" : "hero",
			"value" : 5
		}]
	}]
}
</pre>

<p>
We can see at the top level we have an array called "history" that will be full of objects. Each of these objects will have two fields, "pos" which represents the timestep of the world you are defining the state for, and "data" which itself is another array that actually specifies the state. In this file, we'll only be defining the state for timestep 0, but additional entries in the history array can be added for additional timesteps.
</p>

<p>
So far, we've added three bits of state -- we've given the character "love" the trait "anyone", we've given the character "hero" a strength value of 0, but we've also given the hero an intelligence of 5. Each of these atomic bits of state are what we refer to when we say predicate, and you'll see that they are intimately connected to the social schema you defined above. You specify the <i>class</i> and the </i>type</i> of the social state you are referring to, both of which must be defined in your social schema. As you may recall, our schema did indeed define the class "trait" of which one of its types is "anyone" just as it has the class "attribute" with the types "strength" and "intelligence." The "first" property is referring to the name of the character that the state applies to, and these should be names that were defined in your cast file (just as "hero" and "love" were). The value is what the starting state should actually be -- a strength of 0, intelligence of 5, and a confirmation that the love has the trait anyone in this case.
</p>

<p>
Any predicate that has the direction type "directed" or "recipricol" will need to have an additional property, "second", defined, which specifies the second character involved. (for example, the target of a character's attraction).
</p>

<p>
Now that we've walked through the basic structure of the history file, it won't be so scary when we take in the whole thing at once, eh?
</p>

<h3>Complete History File</h3>
<pre class="prettyprint">
{
	"history": [{
		"pos": 0,
		"data": [{
			"class" : "trait",
			"type" : "hero",
			"first" : "hero",
			"value" : true
				},{
			"class" : "trait",
			"type" : "love",
			"first" : "love",
			"value" : true
				},{
			"class" : "trait",
			"type" : "rival",
			"first" : "rival",
			"value" : true
				},{
			"class" : "trait",
			"type" : "anyone",
			"first" : "hero",
			"value" : true
				},{
			"class" : "trait",
			"type" : "anyone",
			"first" : "rival",
			"value" : true
				},{
			"class" : "trait",
			"type" : "anyone",
			"first" : "love",
			"value" : true
				},{
			"class" : "attribute",
			"type" : "strength",
			"first" : "hero",
			"value" : 0
			},{
			"class" : "attribute",
			"type" : "intelligence",
			"first" : "hero",
			"value" : 5
			}
		]}
	]
}
</pre>

<h2>Defining the Social Rules of Your World</h2>

<p>
	Okay. This is gonna be a bit of a doozy, but once you get it under your belt you'll find that it isn't really that bad. We're gonna talk about filling up your social world with rules. Rules come in two varieties: <b>Trigger Rules</b> and <b>Volition Rules</b>.
</p>

<p>
	<b>Trigger Rules</b> check to see if the social state meets certain criterea, and if it does, applies a change to it. One example of a trigger rule might be to check if a character is cheating on their lover -- you could write a trigger rule that checks if that character is dating two or more people at the same time, and if they are, label them as a cheater so that future prospects know to be wary of the shmuck.
</p>

<p>
	<b>Volition Rules</b> on the other hand are rules that help determine the types of actions that the characters want to take. Volition rules are tied to an intent; the concept of the intent you may recall from when we were defining the "allowIntent" property for each class in our schema file, above. Example intents could be thought of as "raise closeness" or "loser attraction". Eventually, every character in your world will have some amount (which could potentially be negative) of desire to do every possible intent towards every other possible character. And, as we'll see, these intents are then tied to actions which can be performed to ultimately change the social state.
</p>

<p>
	To author both types of these rules, you'll probably going to want to use the authoring tool that came packaged with CiF. We'll look at the raw json of a rule (which is ultimately what the output of the authoring tool is), just so that we feel comfortable knowing what the different parts of a rule are.
</p>

<pre class="prettyprint">
{
	"fileName": "triggerRules",
	"type": "trigger",
	"rules": [
		{
			"name": "Rival is always confident",
			"conditions": [
				{
					"class": "trait",
					"type": "rival",
					"first": "someone",
					"value": true
				}
			],
			"effects": [
				{
					"class": "mood",
					"type": "confident",
					"first": "someone",
					"value": true
				}
			],
			"origin": "triggerRules",
			"id": "triggerRules_1"
		}
	]
}
</pre>

<p>
	So, above we can see the beginnings of our trigger rule file. We've given it a name (in the "fileName" property) of "triggerRules" (though we could have given it any name), and we've specified it's "type" to be "trigger" (the only other valid value here would have been volition). We then have an array of "rules", although this particular example above only has a single entry in this array.
</p>

<p>
	That single rule (and all rules that would go in the array) has a "name" field, which is just meant to be a helpful reminder to you, the author, what the rule does. It has an array of conditions, an array of effects, and then an "origin" and "id" property that is generated and used by the CiF authoring tool and we can safely ignore here. The conditions and the effects are specifically arrays of predicates, which we spoke about above. If all of the predicates in the conditions array hold true, then all of the predicates in the effects array will be carried out and change the world.
</p>

<p>
	Here, in the conditions array, we're checking to see if there exists some character that we're calling "someone" who has the trait "rival." Our use of the word "someone" was totally arbitrary; we could have used any string we wanted. All that matters is that we are consistent in our use of it, because any characters that have the trait rival are going to become 'bound' to that string "someone" while this rule is evaluated. We can see in the effects array of this rule, we apply the "confident" mood to that same "someone" that was found in the conditions. <i>You can only make use of roles in the effects that you first referenced in the conditions.</i>
</p>

<p>
	And that's the basics of a trigger rule! Again, you probably won't be building them directly in a text file, but here are all of the trigger rules used in Lovers and Rivals for your perusing pleasure. For consistency with the rest of the tutorial, plop 'em in a file called "triggerRules.json'
</p>

<h3>Complete Trigger Rules</h3>
<pre class="prettyprint">
{
	"fileName": "triggerRules",
	"type": "trigger",
	"rules": [
		{
			"name": "Rival is always confident",
			"conditions": [
				{
					"class": "trait",
					"type": "rival",
					"first": "someone",
					"value": true
				}
			],
			"effects": [
				{
					"class": "mood",
					"type": "confident",
					"first": "someone",
					"value": true
				}
			],
			"origin": "triggerRules",
			"id": "triggerRules_1"
		},
		{
			"name": "Love is repulsed by self indulged people",
			"conditions": [
				{
					"class": "trait",
					"type": "love",
					"first": "theLove",
					"value": true
				},
				{
					"class": "SFDBLabelUndirected",
					"type": "self-involved",
					"first": "someone",
					"value": true
				},
				{
					"class": "SFDBLabelUndirected",
					"type": "self-involved",
					"first": "someoneElse",
					"value": false
				}
			],
			"effects": [
				{
					"class": "feeling",
					"type": "closeness",
					"first": "theLove",
					"second": "someoneElse",
					"value": 10,
					"operator": "+"
				}
			],
			"origin": "triggerRules",
			"id": "triggerRules_2"
		},
		{
			"name": "People are repulsed when they are the recipients of romantic failures",
			"conditions": [
				{
					"class": "SFDBLabel",
					"type": "romantic-failure",
					"first": "wouldBeLover",
					"second": "victim",
					"value": true
				},
				{
					"class": "SFDBLabel",
					"type": "romantic-failure",
					"first": "someoneElse",
					"second": "victim",
					"value": false
				}
			],
			"effects": [
				{
					"class": "feeling",
					"type": "closeness",
					"first": "victim",
					"second": "someoneElse",
					"value": 10,
					"operator": "+"
				}
			],
			"origin": "triggerRules",
			"id": "triggerRules_3"
		}
	]
}
</pre>

<p>
Volition rules look very similar to trigger rules, with a single major difference: the predicates in the effects array aren't going to directly change the state, but will rather adjust character's volitions scores to perform certain actions. Let's illustrate that with a quick look at the raw json of a volition rule.
</p>

<pre class="prettyprint">
{
	"fileName": "volitionRules",
	"type": "volition",
	"rules": [
		{
			"name": "Everyone Wants to Increase Closeness",
			"conditions": [
				{
					"class": "feeling",
					"type": "closeness",
					"first": "x",
					"second": "y",
					"operator": "&gt;",
					"value": -10
				}
			],
			"effects": [
				{
					"class": "feeling",
					"type": "closeness",
					"first": "x",
					"second": "y",
					"weight": 5,
					"intentDirection": true,
					"value": true
				}
			],
			"origin": "volitionRules",
			"id": "volitionRules_2"
		}
	]
}
</pre>

<p>
This should largely look similar to the trigger rule introduced above. The difference is in the effects array. One thing to note is that this is a predicate that involves two people, and so both "first" and "second" is defined and are filled with the "x" and "y" that were bound when evaluating the conditions of the rule; namely that 'x' represents some character whose closeness for another character "y" is less than -10. As you may recall from the schema that we defined together, the minimum value of feelings is 0, which means that every pair of characters x and y are guaranteed to have a closeness value greater than 10.
</p>

<p>
So we dive into the effects of this rule, and we see a couple of properties here that we haven't seen in predicaes before. One is the "weight" field, which here is set to 5. The other is the "intentDirection" field, which is set to true. The weight refers to the effect it has on the character's volition -- positive numbers raise volition, and negative numbers lower it. The larger the absolute value of the number, the greater the effect. The intentDirection refers to whether or not the character wants to increase the value of the type, or decrease it. This means that there are essentially four different combinations of volitions. We'll use the term 'closeness' for convenience in this table, but the type closeness (and the class "feeling") could of course be substituted for anything that you've set allowIntent to be true for in your schema.
</p>

<table>
<tr><td><b>Positive Weight, Negative intentDirection</b>:<BR> Character WANTS to DECREASE closeness.</td><td><b>Positive Weight, Positive intentDirection</b>:<br> Character WANTS to INCREASE closeness.</td> </tr>
<tr><td><b>Negative Weight, Negative intentDirection</b>:<BR> Character DOESN'T WANT to DECREASE closeness</td><td><b>Negative Weight, Positive intentDirection</b>:<BR> Character DOESN'T WANT to INCREASE closeness.</td></tr>
</table>

So, see, not too crazy, right? And of course, ultimately you'll have lots of rules in your system, with everything kind of competing with each other to determine what your characters want to do. Some rules might have a character want to increase their volition to do something towards a character, while another rule might decrease that same volition towards that same character. In the end, the character's volition is the sum of all of the weights from rules that held true for a given intentDirection. Depending on how you author your system, this means that it would be possible for characters to both simultaneously want to increase and decrease closeness towards the same person--a conflict not alltogether dissimilar from the contradictions of real life.

Now that we're clearly all experts on volition rules, we'll present to you the remainder of the volition rules used in Lovers and Rivals (which we suggest storing in a file called volitionRules.json). Again, in real life you'd be authoring these rules using the authoring tool, but for tutorial purposes we'll just hand you over the code.

<h3>Complete Volition Rules</h3>
<pre class="prettyprint">
{
	"fileName": "volitionRules",
	"type": "volition",
	"rules": [
		{
			"name": "Everyone Wants to Increase Closeness",
			"conditions": [
				{
					"class": "feeling",
					"type": "closeness",
					"first": "x",
					"second": "y",
					"operator": ">",
					"value": -10
				}
			],
			"effects": [
				{
					"class": "feeling",
					"type": "closeness",
					"first": "x",
					"second": "y",
					"weight": 5,
					"intentDirection": true,
					"value": true
				}
			],
			"origin": "volitionRules",
			"id": "volitionRules_2"
		},
		{
			"name": "The hero REALLY wants to increase closeness to the love",
			"conditions": [
				{
					"class": "trait",
					"type": "hero",
					"first": "x",
					"value": true
				},
				{
					"class": "trait",
					"type": "love",
					"first": "y",
					"value": true
				}
			],
			"effects": [
				{
					"class": "feeling",
					"type": "closeness",
					"first": "x",
					"second": "y",
					"weight": 20,
					"intentDirection": true
				}
			],
			"origin": "volitionRules",
			"id": "volitionRules_3"
		},
		{
			"name": "The love generally doesn't want to get close to the hero",
			"conditions": [
				{
					"class": "trait",
					"type": "love",
					"first": "love",
					"value": true
				},
				{
					"class": "trait",
					"type": "hero",
					"first": "hero",
					"value": true
				}
			],
			"effects": [
				{
					"class": "feeling",
					"type": "closeness",
					"first": "love",
					"second": "hero",
					"weight": -10,
					"intentDirection": true
				}
			],
			"origin": "volitionRules",
			"id": "volitionRules_4"
		},
		{
			"name": "Weak people desire strength",
			"conditions": [
				{
					"class": "attribute",
					"type": "strength",
					"first": "someone",
					"value": 10,
					"operator": "&lt;"
				}
			],
			"effects": [
				{
					"class": "attribute",
					"type": "strength",
					"first": "someone",
					"weight": 5,
					"intentDirection": true,
					"value": true
				}
			],
			"origin": "volitionRules",
			"id": "volitionRules_5"
		},
		{
			"name": "The hero doesn't particularly want to get closer to the rival",
			"conditions": [
				{
					"class": "trait",
					"type": "hero",
					"first": "hero",
					"value": true
				},
				{
					"class": "trait",
					"type": "rival",
					"first": "rival",
					"value": true
				}
			],
			"effects": [
				{
					"class": "feeling",
					"type": "closeness",
					"first": "hero",
					"second": "rival",
					"weight": -10,
					"intentDirection": true,
					"value": true
				}
			],
			"origin": "volitionRules",
			"id": "volitionRules_6"
		},
		{
			"name": "People want to get closer to smart people",
			"conditions": [
				{
					"class": "attribute",
					"type": "intelligence",
					"first": "Smarty",
					"value": 20,
					"operator": ">"
				},
				{
					"class": "trait",
					"type": "anyone",
					"first": "onlooker",
					"value": true
				}
			],
			"effects": [
				{
					"class": "feeling",
					"type": "closeness",
					"first": "onlooker",
					"second": "Smarty",
					"weight": 5,
					"intentDirection": true,
					"value": true
				}
			],
			"origin": "volitionRules",
			"id": "volitionRules_7"
		},
		{
			"name": "People want to get closer to strong people",
			"conditions": [
				{
					"class": "trait",
					"type": "anyone",
					"first": "onlooker",
					"value": true
				},
				{
					"class": "attribute",
					"type": "strength",
					"first": "strongperson",
					"value": 20,
					"operator": ">"
				}
			],
			"effects": [
				{
					"class": "feeling",
					"type": "closeness",
					"first": "onlooker",
					"second": "other",
					"weight": 5,
					"intentDirection": true,
					"value": true
				}
			],
			"origin": "volitionRules",
			"id": "volitionRules_8"
		},
		{
			"name": "Everyone desires intelligence",
			"conditions": [
				{
					"class": "trait",
					"type": "anyone",
					"first": "someone",
					"value": true
				}
			],
			"effects": [
				{
					"class": "attribute",
					"type": "intelligence",
					"first": "someone",
					"weight": 5,
					"intentDirection": true,
					"value": true
				}
			],
			"origin": "volitionRules",
			"id": "volitionRules_9"
		},
		{
			"name": "Everyone Desires Strength",
			"conditions": [
				{
					"class": "trait",
					"type": "anyone",
					"first": "someone",
					"value": true
				}
			],
			"effects": [
				{
					"class": "attribute",
					"type": "strength",
					"first": "someone",
					"weight": 5,
					"intentDirection": true,
					"value": true
				}
			],
			"origin": "volitionRules",
			"id": "volitionRules_10"
		}
	]
}
</pre>

<h2>Defining the Social Actions of Your Game</h2>

<p>
	
</p>

<p>
Feeling good? Good! Time to move on to Part 4!
</p>


</body>
</html>